"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "../fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "../fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "../fhevm/GenericStringStorage";

// Simple logger for development
const isDev = process.env.NODE_ENV === 'development';
const logger = {
  debug: (message: string, ...args: any[]) => {
    if (isDev) {
      console.log(`[DEBUG] ${message}`, ...args);
    }
  }
};

/*
  The following two files are automatically generated by the script located at
  <root>/scripts/genabi.mjs. This script parses the
  <root>/packages/secure-study/deployments directory to retrieve
  deployment information for EncryptedStudyTracker.sol:

  - <root>/packages/site/abi/abi/EncryptedStudyTrackerABI.ts
  - <root>/packages/site/abi/abi/EncryptedStudyTrackerAddresses.ts
*/
import { EncryptedStudyTrackerAddresses } from "../abi/EncryptedStudyTrackerAddresses";
import { EncryptedStudyTrackerABI } from "../abi/EncryptedStudyTrackerABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};
type EncryptedStudyTrackerInfoType = {
  abi: typeof EncryptedStudyTrackerABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves EncryptedStudyTracker contract metadata for the given EVM `chainId`.
 *
 * The ABI and address book are **generated** from the `secure-study`
 * artifacts into the `@/abi` folder at build time. This function performs a
 * simple lookup in that generated map.
 *
 * Behavior:
 * - If `chainId` is `undefined` or not found in the map, returns ABI only.
 * - Otherwise returns `{ abi, address, chainId, chainName }`.
 *
 * @param chainId - Target chain id (e.g., 1, 5, 11155111). `undefined` returns ABI-only.
 * @returns Contract info for the chain or ABI-only fallback.
 * @example
 * const { abi, address } = getEncryptedStudyTrackerByChainId(chainId);
 */
function getEncryptedStudyTrackerByChainId(
  chainId: number | undefined
): EncryptedStudyTrackerInfoType {
  if (!chainId) {
    return { abi: EncryptedStudyTrackerABI.abi };
  }

  const entry =
    EncryptedStudyTrackerAddresses[chainId.toString() as keyof typeof EncryptedStudyTrackerAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    console.warn(`EncryptedStudyTracker: Unsupported chainId ${chainId}. Only localhost (31337) is supported for this demo.`);
    return { abi: EncryptedStudyTrackerABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: EncryptedStudyTrackerABI.abi,
  };
}

/*
 * Main EncryptedStudyTracker React component with study time tracking functionality
 *  - "Record Study Time" button: allows you to record encrypted study time
 *  - "Decrypt Daily Time" button: allows you to decrypt the current day's study time handle
 *  - "Decrypt Total Time" button: allows you to decrypt the total accumulated study time handle
 */
export const useEncryptedStudyTracker = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs (refs are mostly used to access latest React values and avoid
  // state dependencies). Consider @tanstack/react-query as an alternative to
  // handle async operations like FHEVM encryption/decryption
  //////////////////////////////////////////////////////////////////////////////

  const [dailyStudyTimeHandle, setDailyStudyTimeHandle] = useState<string | undefined>(undefined);
  const [totalStudyTimeHandle, setTotalStudyTimeHandle] = useState<string | undefined>(undefined);
  const [clearDailyTime, setClearDailyTime] = useState<ClearValueType | undefined>(undefined);
  const [clearTotalTime, setClearTotalTime] = useState<ClearValueType | undefined>(undefined);
  const [currentDate, setCurrentDate] = useState<number | undefined>(undefined);
  const [lastStudyDate, setLastStudyDate] = useState<number | undefined>(undefined);

  const clearDailyTimeRef = useRef<ClearValueType>(undefined);
  const clearTotalTimeRef = useRef<ClearValueType>(undefined);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecryptingDaily, setIsDecryptingDaily] = useState<boolean>(false);
  const [isDecryptingTotal, setIsDecryptingTotal] = useState<boolean>(false);
  const [isRecording, setIsRecording] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const studyTrackerRef = useRef<EncryptedStudyTrackerInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingDailyRef = useRef<boolean>(isDecryptingDaily);
  const isDecryptingTotalRef = useRef<boolean>(isDecryptingTotal);
  const isRecordingRef = useRef<boolean>(isRecording);

  const isDailyDecrypted = dailyStudyTimeHandle && dailyStudyTimeHandle === clearDailyTime?.handle;
  const isTotalDecrypted = totalStudyTimeHandle && totalStudyTimeHandle === clearTotalTime?.handle;

  //////////////////////////////////////////////////////////////////////////////
  // EncryptedStudyTracker
  //////////////////////////////////////////////////////////////////////////////

  const studyTracker = useMemo(() => {
    const c = getEncryptedStudyTrackerByChainId(chainId);

    studyTrackerRef.current = c;

    if (!c.address) {
      setMessage(`EncryptedStudyTracker deployment not found for chainId=${chainId}.`);
    } else if (chainId !== undefined) {
      // Clear any previous error messages when we have a valid deployment
      setMessage("");
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Study Time Handles
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!studyTracker) {
      return undefined;
    }
    return (Boolean(studyTracker.address) && studyTracker.address !== ethers.ZeroAddress);
  }, [studyTracker]);

  const canGetStudyTimes = useMemo(() => {
    return studyTracker.address && ethersReadonlyProvider && !isRefreshing;
  }, [studyTracker.address, ethersReadonlyProvider, isRefreshing]);

  const refreshStudyTimes = useCallback(() => {
    // console.log("[useEncryptedStudyTracker] call refreshStudyTimes()");
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !studyTrackerRef.current ||
      !studyTrackerRef.current?.chainId ||
      !studyTrackerRef.current?.address ||
      !ethersReadonlyProvider
    ) {
      setDailyStudyTimeHandle(undefined);
      setTotalStudyTimeHandle(undefined);
      setCurrentDate(undefined);
      setLastStudyDate(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = studyTrackerRef.current.chainId;
    const thisStudyTrackerAddress = studyTrackerRef.current.address;

    const thisStudyTrackerContract = new ethers.Contract(
      thisStudyTrackerAddress,
      studyTrackerRef.current.abi,
      ethersReadonlyProvider
    );

    console.log(`[refreshStudyTimes] Calling contract methods on address: ${thisStudyTrackerAddress}`);

    // Get the user address from the signer and call contract methods
    const getUserAddressAndCall = async () => {
      const userAddress = ethersSigner ? await ethersSigner.getAddress() : "0x0000000000000000000000000000000000000000";
      console.log(`[refreshStudyTimes] Using user address: ${userAddress}`);

      return Promise.all([
        thisStudyTrackerContract.getDailyStudyTime(userAddress),
        thisStudyTrackerContract.getTotalStudyTime(userAddress),
        thisStudyTrackerContract.getCurrentDate(),
        thisStudyTrackerContract.getLastStudyDate(userAddress),
        // Debug functions
        thisStudyTrackerContract.debugDailyInitialized(userAddress),
        thisStudyTrackerContract.debugTotalInitialized(userAddress),
        thisStudyTrackerContract.debugLastStudyDate(userAddress)
      ]);
    };

    getUserAddressAndCall()
      .then(([dailyHandle, totalHandle, currentDateValue, lastDateValue, dailyInitialized, totalInitialized, debugLastDate]) => {
        console.log("[refreshStudyTimes] getDailyStudyTime()=" + dailyHandle);
        console.log("[refreshStudyTimes] getTotalStudyTime()=" + totalHandle);
        console.log("[refreshStudyTimes] getCurrentDate()=" + currentDateValue);
        console.log("[refreshStudyTimes] getLastStudyDate()=" + lastDateValue);
        console.log("[refreshStudyTimes] debugDailyInitialized()=" + dailyInitialized);
        console.log("[refreshStudyTimes] debugTotalInitialized()=" + totalInitialized);
        console.log("[refreshStudyTimes] debugLastStudyDate()=" + debugLastDate);

        console.log(`[refreshStudyTimes] Raw daily value:`, dailyHandle);
        console.log(`[refreshStudyTimes] Raw total value:`, totalHandle);

        if (
          sameChain.current(thisChainId) &&
          thisStudyTrackerAddress === studyTrackerRef.current?.address
        ) {
          // For simplified contract, simulate encrypted handles
          // In a real FHE app, these would be actual encrypted handles from FHE operations
          // Here we simulate by storing the plain values but displaying them as "encrypted"
          // The actual decryption happens when user clicks decrypt button
          const dailyValue = dailyInitialized ? dailyHandle.toString() : "0";
          const totalValue = totalInitialized ? totalHandle.toString() : "0";

          setDailyStudyTimeHandle(dailyValue);
          setTotalStudyTimeHandle(totalValue);
          setCurrentDate(Number(currentDateValue));
          setLastStudyDate(Number(lastDateValue));
        }

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("EncryptedStudyTracker.getStudyTimes() call failed! error=" + e);

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, sameChain, ethersSigner]); // Add sameChain and ethersSigner to the dependency array

  // Auto refresh the study time handles when provider or contract changes
  useEffect(() => {
    refreshStudyTimes();
  }, [ethersReadonlyProvider, studyTracker.address]); // Re-run when provider or contract address changes

  //////////////////////////////////////////////////////////////////////////////
  // Study Time Handle Decryption
  //////////////////////////////////////////////////////////////////////////////

  const canDecryptDaily = useMemo(() => {
    const hasAddress = !!studyTracker.address;
    const hasInstance = !!instance;
    const hasSigner = !!ethersSigner;
    const notRefreshing = !isRefreshing;
    const notDecrypting = !isDecryptingDaily;
    // For simplified contract, check if we have a non-zero plain value
    const hasValue = dailyStudyTimeHandle && dailyStudyTimeHandle !== "0" && dailyStudyTimeHandle !== ethers.ZeroHash;
    const notAlreadyDecrypted = !clearDailyTime || clearDailyTime.clear !== dailyStudyTimeHandle;

    const result = Boolean(
      hasAddress &&
      hasInstance &&
      hasSigner &&
      notRefreshing &&
      notDecrypting &&
      hasValue &&
      notAlreadyDecrypted
    );

    console.log(`[canDecryptDaily] Result: ${result}`, {
      hasAddress,
      hasInstance,
      hasSigner,
      notRefreshing,
      notDecrypting,
      hasValue,
      notAlreadyDecrypted,
      dailyStudyTimeHandle,
    });

    return result;
  }, [
    studyTracker.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecryptingDaily,
    dailyStudyTimeHandle,
    clearDailyTime,
  ]);

  const canDecryptTotal = useMemo(() => {
    return (
      studyTracker.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecryptingTotal &&
      totalStudyTimeHandle &&
      totalStudyTimeHandle !== "0" &&
      totalStudyTimeHandle !== ethers.ZeroHash && // fhe handle not initialized
      (!clearTotalTime || clearTotalTime.clear !== totalStudyTimeHandle) // not yet decrypted
    );
  }, [
    studyTracker.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecryptingTotal,
    totalStudyTimeHandle,
    clearTotalTime,
  ]);

  /**
   * Asynchronous FHEVM decryption process for daily study time.
   */
  const decryptDailyStudyTime = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingDailyRef.current) {
      return;
    }

    if (!studyTracker.address || !instance || !ethersSigner) {
      return;
    }

    // Already computed
    if (dailyStudyTimeHandle === clearDailyTimeRef.current?.handle) {
      return;
    }

    if (!dailyStudyTimeHandle) {
      setClearDailyTime(undefined);
      clearDailyTimeRef.current = undefined;
      return;
    }

    if (dailyStudyTimeHandle === ethers.ZeroHash) {
      setClearDailyTime({ handle: dailyStudyTimeHandle, clear: BigInt(0) });
      clearDailyTimeRef.current = { handle: dailyStudyTimeHandle, clear: BigInt(0) };
      return;
    }

    const thisChainId = chainId;
    const thisStudyTrackerAddress = studyTracker.address;
    const thisDailyHandle = dailyStudyTimeHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingDailyRef.current = true;
    setIsDecryptingDaily(true);
    setMessage("Requesting decryption authorization from contract...");

    const run = async () => {
      const isStale = () =>
        thisStudyTrackerAddress !== studyTrackerRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        if (!studyTrackerRef.current) {
          setMessage("Contract reference not available");
          return;
        }

        // First, call the contract method to request decryption authorization
        // This will create a transaction and trigger MetaMask popup
        const contract = new ethers.Contract(
          thisStudyTrackerAddress,
          studyTrackerRef.current.abi,
          thisEthersSigner
        );

        // Generate a unique request ID (using timestamp for simplicity)
        const requestId = Date.now();

        setMessage(`Calling requestDecryptDaily(${requestId}) - please confirm in MetaMask...`);

        // This call will trigger MetaMask popup - since it's a transaction, we wait for confirmation
        const txResponse = await contract.requestDecryptDaily(requestId);

        // Wait for transaction confirmation
        console.log('[decryptDailyStudyTime] Waiting for transaction confirmation...');
        const txReceipt = await txResponse.wait();
        console.log('[decryptDailyStudyTime] Transaction confirmed, receipt:', txReceipt);

        // Since we can't get the return value from a transaction, we need to get the value directly from contract state
        // For this simplified version, we call getDailyStudyTime to get the plain value
        const plainValue = await contract.getDailyStudyTime(ethersSigner.address);
        console.log('[decryptDailyStudyTime] Got plain value from getDailyStudyTime:', plainValue, typeof plainValue);

        let clearValue;
        if (typeof plainValue === 'number' || typeof plainValue === 'bigint') {
          clearValue = BigInt(plainValue);
        } else if (typeof plainValue === 'string') {
          clearValue = BigInt(plainValue);
        } else if (plainValue && typeof plainValue === 'object' && 'toString' in plainValue) {
          // Handle BigNumber objects
          clearValue = BigInt(plainValue.toString());
        } else {
          console.error('[decryptDailyStudyTime] Unexpected plainValue format:', plainValue, typeof plainValue);
          throw new Error('Unexpected plainValue format from contract call');
        }

        setMessage("Decryption completed! Daily study time: " + clearValue + " minutes");

        if (isStale()) {
          setMessage("Ignore decryption result");
          return;
        }
        setClearDailyTime({ handle: thisDailyHandle, clear: clearValue });
        clearDailyTimeRef.current = {
          handle: thisDailyHandle,
          clear: clearValue,
        };

        setMessage(
          "Daily study time clear value is " + clearDailyTimeRef.current.clear + " minutes"
        );
      } finally {
        isDecryptingDailyRef.current = false;
        setIsDecryptingDaily(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    studyTracker.address,
    instance,
    dailyStudyTimeHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  /**
   * Asynchronous FHEVM decryption process for total study time.
   */
  const decryptTotalStudyTime = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingTotalRef.current) {
      return;
    }

    if (!studyTracker.address || !instance || !ethersSigner) {
      return;
    }

    // Already computed
    if (totalStudyTimeHandle === clearTotalTimeRef.current?.handle) {
      return;
    }

    if (!totalStudyTimeHandle) {
      setClearTotalTime(undefined);
      clearTotalTimeRef.current = undefined;
      return;
    }

    if (totalStudyTimeHandle === ethers.ZeroHash) {
      setClearTotalTime({ handle: totalStudyTimeHandle, clear: BigInt(0) });
      clearTotalTimeRef.current = { handle: totalStudyTimeHandle, clear: BigInt(0) };
      return;
    }

    const thisChainId = chainId;
    const thisStudyTrackerAddress = studyTracker.address;
    const thisTotalHandle = totalStudyTimeHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingTotalRef.current = true;
    setIsDecryptingTotal(true);
    setMessage("Requesting decryption authorization from contract...");

    const run = async () => {
      const isStale = () =>
        thisStudyTrackerAddress !== studyTrackerRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        if (!studyTrackerRef.current) {
          setMessage("Contract reference not available");
          return;
        }

        // First, call the contract method to request decryption authorization
        // This will create a transaction and trigger MetaMask popup
        const contract = new ethers.Contract(
          thisStudyTrackerAddress,
          studyTrackerRef.current.abi,
          thisEthersSigner
        );

        // Generate a unique request ID (using timestamp for simplicity)
        const requestId = Date.now();

        setMessage(`Calling requestDecryptTotal(${requestId}) - please confirm in MetaMask...`);

        // This call will trigger MetaMask popup - since it's a transaction, we wait for confirmation
        const txResponse = await contract.requestDecryptTotal(requestId);

        // Wait for transaction confirmation
        console.log('[decryptTotalStudyTime] Waiting for transaction confirmation...');
        const txReceipt = await txResponse.wait();
        console.log('[decryptTotalStudyTime] Transaction confirmed, receipt:', txReceipt);

        // Since we can't get the return value from a transaction, we need to get the value directly from contract state
        // For this simplified version, we call getTotalStudyTime to get the plain value
        const plainValue = await contract.getTotalStudyTime(ethersSigner.address);
        console.log('[decryptTotalStudyTime] Got plain value from getTotalStudyTime:', plainValue, typeof plainValue);

        let clearValue;
        if (typeof plainValue === 'number' || typeof plainValue === 'bigint') {
          clearValue = BigInt(plainValue);
        } else if (typeof plainValue === 'string') {
          clearValue = BigInt(plainValue);
        } else if (plainValue && typeof plainValue === 'object' && 'toString' in plainValue) {
          // Handle BigNumber objects
          clearValue = BigInt(plainValue.toString());
        } else {
          console.error('[decryptTotalStudyTime] Unexpected plainValue format:', plainValue, typeof plainValue);
          throw new Error('Unexpected plainValue format from contract call');
        }

        setMessage("Decryption completed! Total study time: " + clearValue + " minutes");

        if (isStale()) {
          setMessage("Ignore decryption result");
          return;
        }
        setClearTotalTime({ handle: thisTotalHandle, clear: clearValue });
        clearTotalTimeRef.current = {
          handle: thisTotalHandle,
          clear: clearValue,
        };

        setMessage(
          "Total study time clear value is " + clearTotalTimeRef.current.clear + " minutes"
        );
      } finally {
        isDecryptingTotalRef.current = false;
        setIsDecryptingTotal(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    studyTracker.address,
    instance,
    totalStudyTimeHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  //////////////////////////////////////////////////////////////////////////////
  // Study Time Recording
  //////////////////////////////////////////////////////////////////////////////

  const canRecordStudyTime = useMemo(() => {
    return (
      studyTracker.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isRecording
    );
  }, [studyTracker.address, instance, ethersSigner, isRefreshing, isRecording]);

  /**
   * Asynchronous FHEVM encryption process for recording study time.
   */
  const recordStudyTime = useCallback(
    (studyTimeMinutes: number) => {
      console.log(`[useEncryptedStudyTracker] recordStudyTime called with ${studyTimeMinutes} minutes`);
      console.log(`[recordStudyTime] DEBUG - Contract address: ${studyTracker.address}`);
      console.log(`[recordStudyTime] DEBUG - Ethers signer address: ${ethersSigner?.address}`);
      console.log(`[recordStudyTime] DEBUG - Chain ID: ${chainId}`);

      if (isRefreshingRef.current || isRecordingRef.current || studyTimeMinutes <= 0) {
        console.log(`[useEncryptedStudyTracker] recordStudyTime rejected: isRefreshing=${isRefreshingRef.current}, isRecording=${isRecordingRef.current}, studyTimeMinutes=${studyTimeMinutes}`);
        return;
      }

      if (!studyTracker.address || !instance || !ethersSigner) {
        return;
      }

      const thisChainId = chainId;
      const thisStudyTrackerAddress = studyTracker.address;
      const thisEthersSigner = ethersSigner;
      const thisStudyTrackerContract = new ethers.Contract(
        thisStudyTrackerAddress,
        studyTracker.abi,
        thisEthersSigner
      );

      const opMsg = `recordStudyTime(${studyTimeMinutes} minutes)`;

      isRecordingRef.current = true;
      setIsRecording(true);
      setMessage(`Start ${opMsg}...`);

      const run = async () => {
        // let the browser repaint before running 'input.encrypt()' (CPU-costly)
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisStudyTrackerAddress !== studyTrackerRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          console.log(`[recordStudyTime] Simplified version: calling contract directly with plain value`);

          if (isStale()) {
            setMessage(`Ignore ${opMsg}`);
            return;
          }

          setMessage(`Call ${opMsg}...`);

          console.log(`[recordStudyTime] Calling contract.recordStudyTime with value: ${studyTimeMinutes}`);

          // Call contract with plain uint256 value (simplified version)
          const tx: ethers.TransactionResponse =
            await thisStudyTrackerContract.recordStudyTime(
              studyTimeMinutes, // Plain value instead of encrypted handle
              "0x00" // Dummy proof (ignored in simplified contract)
            );

          console.log(`[recordStudyTime] Transaction sent, hash: ${tx.hash}`);
          setMessage(`Wait for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          console.log(`[recordStudyTime] Transaction mined, status: ${receipt?.status}, gas used: ${receipt?.gasUsed}`);
          setMessage(`Call ${opMsg} completed status=${receipt?.status}`);

          console.log(`[recordStudyTime] Transaction completed with status: ${receipt?.status}`);
          console.log(`[recordStudyTime] Transaction hash: ${tx.hash}`);
          console.log(`[recordStudyTime] Block number: ${receipt?.blockNumber}`);

          if (isStale()) {
            setMessage(`Ignore ${opMsg}`);
            return;
          }

          // Wait a bit for transaction to be fully processed
          setTimeout(() => {
            console.log(`[recordStudyTime] Calling refreshStudyTimes after 3 second delay`);
            refreshStudyTimes();
          }, 3000);
        } catch (e) {
          setMessage(`${opMsg} Failed! Error: ${e}`);
        } finally {
          isRecordingRef.current = false;
          setIsRecording(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      studyTracker.address,
      studyTracker.abi,
      instance,
      chainId,
      refreshStudyTimes,
      sameChain,
      sameSigner,
    ]
  );

  return {
    contractAddress: studyTracker.address,
    canDecryptDaily,
    canDecryptTotal,
    canGetStudyTimes,
    canRecordStudyTime,
    recordStudyTime,
    decryptDailyStudyTime,
    decryptTotalStudyTime,
    refreshStudyTimes,
    isDailyDecrypted,
    isTotalDecrypted,
    message,
    clearDailyTime: clearDailyTime?.clear,
    clearTotalTime: clearTotalTime?.clear,
    dailyHandle: dailyStudyTimeHandle,
    totalHandle: totalStudyTimeHandle,
    currentDate,
    lastStudyDate,
    isDecryptingDaily,
    isDecryptingTotal,
    isRefreshing,
    isRecording,
    isDeployed
  };
};
